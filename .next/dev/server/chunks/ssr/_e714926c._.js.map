{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/yigitcangenc/Github/Antigravity/web/app/actions/settings.ts"],"sourcesContent":["'use server'\n\nimport { db } from '@/lib/db'\nimport { siteSettings } from '@/db/schema'\nimport { eq } from 'drizzle-orm'\nimport { revalidatePath } from 'next/cache'\n\nexport async function updateSettings(formData: FormData) {\n    const heroTitle = formData.get('heroTitle') as string\n    const heroDescription = formData.get('heroDescription') as string\n    const contactEmail = formData.get('contactEmail') as string\n\n    try {\n        // Upsert logic basically, but we know id='default' exists from seed.\n        await db.update(siteSettings).set({\n            heroTitle,\n            heroDescription,\n            contactEmail,\n            updatedAt: new Date()\n        }).where(eq(siteSettings.id, 'default'))\n    } catch (e) {\n        return { message: 'Failed to update settings' }\n    }\n\n    revalidatePath('/')\n    revalidatePath('/admin/dashboard/settings')\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;;;;;;;AAEO,eAAe,eAAe,QAAkB;IACnD,MAAM,YAAY,SAAS,GAAG,CAAC;IAC/B,MAAM,kBAAkB,SAAS,GAAG,CAAC;IACrC,MAAM,eAAe,SAAS,GAAG,CAAC;IAElC,IAAI;QACA,qEAAqE;QACrE,MAAM,+GAAE,CAAC,MAAM,CAAC,4HAAY,EAAE,GAAG,CAAC;YAC9B;YACA;YACA;YACA,WAAW,IAAI;QACnB,GAAG,KAAK,CAAC,IAAA,wKAAE,EAAC,4HAAY,CAAC,EAAE,EAAE;IACjC,EAAE,OAAO,GAAG;QACR,OAAO;YAAE,SAAS;QAA4B;IAClD;IAEA,IAAA,+IAAc,EAAC;IACf,IAAA,+IAAc,EAAC;AACnB;;;IAnBsB;;AAAA,+OAAA"}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///Users/yigitcangenc/Github/Antigravity/web/app/actions/profile.ts"],"sourcesContent":["'use server'\n\nimport { db } from '@/lib/db'\nimport { admins } from '@/db/schema'\nimport { eq } from 'drizzle-orm'\nimport bcrypt from 'bcryptjs'\nimport { revalidatePath } from 'next/cache'\nimport { cookies } from 'next/headers'\n\nexport async function updatePassword(prevState: any, formData: FormData) {\n    const currentPassword = formData.get('currentPassword') as string\n    const newPassword = formData.get('newPassword') as string\n    const confirmPassword = formData.get('confirmPassword') as string\n\n    if (!currentPassword || !newPassword || !confirmPassword) {\n        return { message: 'All fields are required', success: false }\n    }\n\n    if (newPassword !== confirmPassword) {\n        return { message: 'New passwords do not match', success: false }\n    }\n\n    try {\n        // We need to identify the current user. Since we don't store user ID in cookie (only session flag),\n        // we assume single admin for now OR we should have stored email in cookie.\n        // But the requirement implies \"the user\" -> we can assume strict single user or we need to update auth to store user info.\n        // Given the constraints and typical \"simple admin\" setup, let's update the user 'yigitcangenc@gmail.com' specifically \n        // OR better, fetch the only admin user if we assume single tenant.\n\n        // HOWEVER, a better approach is to store the user email in the cookie.\n        // Since I didn't verify cookie contents changes in auth.ts (it just sets 'admin_session'='true'),\n        // I will assume for this specific request we are updating the main admin user. \n        // To be safer, I'll fetch the first admin found or specific email.\n\n        const user = await db.select().from(admins).limit(1).get(); // Get the single admin\n\n        if (!user) {\n            return { message: 'User not found', success: false }\n        }\n\n        const valid = await bcrypt.compare(currentPassword, user.passwordHash)\n\n        if (!valid) {\n            return { message: 'Current password is incorrect', success: false }\n        }\n\n        const newPasswordHash = await bcrypt.hash(newPassword, 10)\n\n        await db.update(admins)\n            .set({ passwordHash: newPasswordHash })\n            .where(eq(admins.id, user.id))\n\n        return { message: 'Password updated successfully', success: true }\n\n    } catch (e) {\n        console.error(e)\n        return { message: 'Failed to update password', success: false }\n    }\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;;;;;;;AAIO,eAAe,eAAe,SAAc,EAAE,QAAkB;IACnE,MAAM,kBAAkB,SAAS,GAAG,CAAC;IACrC,MAAM,cAAc,SAAS,GAAG,CAAC;IACjC,MAAM,kBAAkB,SAAS,GAAG,CAAC;IAErC,IAAI,CAAC,mBAAmB,CAAC,eAAe,CAAC,iBAAiB;QACtD,OAAO;YAAE,SAAS;YAA2B,SAAS;QAAM;IAChE;IAEA,IAAI,gBAAgB,iBAAiB;QACjC,OAAO;YAAE,SAAS;YAA8B,SAAS;QAAM;IACnE;IAEA,IAAI;QACA,oGAAoG;QACpG,2EAA2E;QAC3E,2HAA2H;QAC3H,uHAAuH;QACvH,mEAAmE;QAEnE,uEAAuE;QACvE,kGAAkG;QAClG,gFAAgF;QAChF,mEAAmE;QAEnE,MAAM,OAAO,MAAM,+GAAE,CAAC,MAAM,GAAG,IAAI,CAAC,sHAAM,EAAE,KAAK,CAAC,GAAG,GAAG,IAAI,uBAAuB;QAEnF,IAAI,CAAC,MAAM;YACP,OAAO;gBAAE,SAAS;gBAAkB,SAAS;YAAM;QACvD;QAEA,MAAM,QAAQ,MAAM,4IAAM,CAAC,OAAO,CAAC,iBAAiB,KAAK,YAAY;QAErE,IAAI,CAAC,OAAO;YACR,OAAO;gBAAE,SAAS;gBAAiC,SAAS;YAAM;QACtE;QAEA,MAAM,kBAAkB,MAAM,4IAAM,CAAC,IAAI,CAAC,aAAa;QAEvD,MAAM,+GAAE,CAAC,MAAM,CAAC,sHAAM,EACjB,GAAG,CAAC;YAAE,cAAc;QAAgB,GACpC,KAAK,CAAC,IAAA,wKAAE,EAAC,sHAAM,CAAC,EAAE,EAAE,KAAK,EAAE;QAEhC,OAAO;YAAE,SAAS;YAAiC,SAAS;QAAK;IAErE,EAAE,OAAO,GAAG;QACR,QAAQ,KAAK,CAAC;QACd,OAAO;YAAE,SAAS;YAA6B,SAAS;QAAM;IAClE;AACJ;;;IAjDsB;;AAAA,+OAAA"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///Users/yigitcangenc/Github/Antigravity/web/.next-internal/server/app/admin/dashboard/settings/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {logout as '00f4fb5eb3be3ed0aca34683c4f23cc8d8cf540698'} from 'ACTIONS_MODULE0'\nexport {login as '6053b55e959f91fc581532ef4ff4459b1ccb77d370'} from 'ACTIONS_MODULE0'\nexport {updateSettings as '40c26afba79d364ae49d3de1075969ba5557ef9ec8'} from 'ACTIONS_MODULE1'\nexport {updatePassword as '605903fbe4ee6b6cd53fc4efde62fc75728cc7c67a'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":";AAAA;AAEA;AACA"}}]
}